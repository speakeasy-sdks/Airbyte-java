/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package WayScript.airbyte_test.models.shared;

import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * WebBackendConnectionRead - Successful operation
 */
public class WebBackendConnectionRead {
    /**
     * Describes the difference between two Airbyte catalogs.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("catalogDiff")
    public CatalogDiff catalogDiff;

    public WebBackendConnectionRead withCatalogDiff(CatalogDiff catalogDiff) {
        this.catalogDiff = catalogDiff;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("catalogId")
    public String catalogId;

    public WebBackendConnectionRead withCatalogId(String catalogId) {
        this.catalogId = catalogId;
        return this;
    }
    
    @JsonProperty("connectionId")
    public String connectionId;

    public WebBackendConnectionRead withConnectionId(String connectionId) {
        this.connectionId = connectionId;
        return this;
    }
    
    @JsonProperty("destination")
    public DestinationRead destination;

    public WebBackendConnectionRead withDestination(DestinationRead destination) {
        this.destination = destination;
        return this;
    }
    
    @JsonProperty("destinationId")
    public String destinationId;

    public WebBackendConnectionRead withDestinationId(String destinationId) {
        this.destinationId = destinationId;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("geography")
    public GeographyEnum geography;

    public WebBackendConnectionRead withGeography(GeographyEnum geography) {
        this.geography = geography;
        return this;
    }
    
    @JsonProperty("isSyncing")
    public Boolean isSyncing;

    public WebBackendConnectionRead withIsSyncing(Boolean isSyncing) {
        this.isSyncing = isSyncing;
        return this;
    }
    
    /**
     * epoch time of the latest sync job. null if no sync job has taken place.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("latestSyncJobCreatedAt")
    public Long latestSyncJobCreatedAt;

    public WebBackendConnectionRead withLatestSyncJobCreatedAt(Long latestSyncJobCreatedAt) {
        this.latestSyncJobCreatedAt = latestSyncJobCreatedAt;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("latestSyncJobStatus")
    public JobStatusEnum latestSyncJobStatus;

    public WebBackendConnectionRead withLatestSyncJobStatus(JobStatusEnum latestSyncJobStatus) {
        this.latestSyncJobStatus = latestSyncJobStatus;
        return this;
    }
    
    @JsonProperty("name")
    public String name;

    public WebBackendConnectionRead withName(String name) {
        this.name = name;
        return this;
    }
    
    /**
     * Method used for computing final namespace in destination
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namespaceDefinition")
    public NamespaceDefinitionTypeEnum namespaceDefinition;

    public WebBackendConnectionRead withNamespaceDefinition(NamespaceDefinitionTypeEnum namespaceDefinition) {
        this.namespaceDefinition = namespaceDefinition;
        return this;
    }
    
    /**
     * Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("namespaceFormat")
    public String namespaceFormat;

    public WebBackendConnectionRead withNamespaceFormat(String namespaceFormat) {
        this.namespaceFormat = namespaceFormat;
        return this;
    }
    
    @JsonProperty("nonBreakingChangesPreference")
    public NonBreakingChangesPreferenceEnum nonBreakingChangesPreference;

    public WebBackendConnectionRead withNonBreakingChangesPreference(NonBreakingChangesPreferenceEnum nonBreakingChangesPreference) {
        this.nonBreakingChangesPreference = nonBreakingChangesPreference;
        return this;
    }
    
    @JsonProperty("notifySchemaChanges")
    public Boolean notifySchemaChanges;

    public WebBackendConnectionRead withNotifySchemaChanges(Boolean notifySchemaChanges) {
        this.notifySchemaChanges = notifySchemaChanges;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("operationIds")
    public String[] operationIds;

    public WebBackendConnectionRead withOperationIds(String[] operationIds) {
        this.operationIds = operationIds;
        return this;
    }
    
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("operations")
    public OperationRead[] operations;

    public WebBackendConnectionRead withOperations(OperationRead[] operations) {
        this.operations = operations;
        return this;
    }
    
    /**
     * Prefix that will be prepended to the name of each stream when it is written to the destination.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("prefix")
    public String prefix;

    public WebBackendConnectionRead withPrefix(String prefix) {
        this.prefix = prefix;
        return this;
    }
    
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("resourceRequirements")
    public ResourceRequirements resourceRequirements;

    public WebBackendConnectionRead withResourceRequirements(ResourceRequirements resourceRequirements) {
        this.resourceRequirements = resourceRequirements;
        return this;
    }
    
    /**
     * if null, then no schedule is set.
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("schedule")
    public ConnectionSchedule schedule;

    public WebBackendConnectionRead withSchedule(ConnectionSchedule schedule) {
        this.schedule = schedule;
        return this;
    }
    
    /**
     * schedule for when the the connection should run, per the schedule type
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scheduleData")
    public ConnectionScheduleData scheduleData;

    public WebBackendConnectionRead withScheduleData(ConnectionScheduleData scheduleData) {
        this.scheduleData = scheduleData;
        return this;
    }
    
    /**
     * determine how the schedule data should be interpreted
     */
    @JsonInclude(Include.NON_ABSENT)
    @JsonProperty("scheduleType")
    public ConnectionScheduleTypeEnum scheduleType;

    public WebBackendConnectionRead withScheduleType(ConnectionScheduleTypeEnum scheduleType) {
        this.scheduleType = scheduleType;
        return this;
    }
    
    @JsonProperty("schemaChange")
    public SchemaChangeEnum schemaChange;

    public WebBackendConnectionRead withSchemaChange(SchemaChangeEnum schemaChange) {
        this.schemaChange = schemaChange;
        return this;
    }
    
    @JsonProperty("source")
    public SourceRead source;

    public WebBackendConnectionRead withSource(SourceRead source) {
        this.source = source;
        return this;
    }
    
    @JsonProperty("sourceId")
    public String sourceId;

    public WebBackendConnectionRead withSourceId(String sourceId) {
        this.sourceId = sourceId;
        return this;
    }
    
    /**
     * Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
     */
    @JsonProperty("status")
    public ConnectionStatusEnum status;

    public WebBackendConnectionRead withStatus(ConnectionStatusEnum status) {
        this.status = status;
        return this;
    }
    
    /**
     * describes the available schema (catalog).
     */
    @JsonProperty("syncCatalog")
    public AirbyteCatalog syncCatalog;

    public WebBackendConnectionRead withSyncCatalog(AirbyteCatalog syncCatalog) {
        this.syncCatalog = syncCatalog;
        return this;
    }
    
    public WebBackendConnectionRead(@JsonProperty("connectionId") String connectionId, @JsonProperty("destination") DestinationRead destination, @JsonProperty("destinationId") String destinationId, @JsonProperty("isSyncing") Boolean isSyncing, @JsonProperty("name") String name, @JsonProperty("nonBreakingChangesPreference") NonBreakingChangesPreferenceEnum nonBreakingChangesPreference, @JsonProperty("notifySchemaChanges") Boolean notifySchemaChanges, @JsonProperty("schemaChange") SchemaChangeEnum schemaChange, @JsonProperty("source") SourceRead source, @JsonProperty("sourceId") String sourceId, @JsonProperty("status") ConnectionStatusEnum status, @JsonProperty("syncCatalog") AirbyteCatalog syncCatalog) {
        this.connectionId = connectionId;
        this.destination = destination;
        this.destinationId = destinationId;
        this.isSyncing = isSyncing;
        this.name = name;
        this.nonBreakingChangesPreference = nonBreakingChangesPreference;
        this.notifySchemaChanges = notifySchemaChanges;
        this.schemaChange = schemaChange;
        this.source = source;
        this.sourceId = sourceId;
        this.status = status;
        this.syncCatalog = syncCatalog;
  }
}
